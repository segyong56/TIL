1. jsx에 대해서 설명해 주세요

<Details>
  <Summary>답변</Summary>
  JSX는 javascript와 XML 합쳐서 탄생한 기존 자바스크립트의 확장문법입니다. 자바스크립트 안에서 html문법을 사용해서
  view를 구성할 수 있게 도와주는 자바스크립트 문법입니다. 즉, html문법을 javascript코드 내부에 쓴 것을 말합니다.
  대표적으로는 React에서 사용되는 문법입니다.
</Details>

2. 클로저 함수의 대한 설명을 해주세요

<Details>
  <Summary>답변</Summary>
  외부함수에 접근할 수 있는 내부 함수 혹은 이러한 원리를 일컫는 용어를 말합니다. 즉, 함수를 반환하는 함수를 정의한 후, 반환된 함수는 
  정의된 함수의 내부함수가 됩니다. 그리고 내부함수는 정의된 함수의 내부에서 선언된 변수를 사용할 수 있습니다. 클로저 함수에서 내부함수는 자신이 생성될 때의 환경 즉 외부함수환경을 기억하여 외부함수의 지역변수에 접근 할 수 있습니다. 이말은 즉, 전역변수를 사용하여 함수를 호출하는 경우 변수가 누군가에 의해 언제든지 변경될 수 있으므로 원하는 값이 아닌 다른 값을 반환한다던지, 오류를 될 수 있는 상황을 만드는데,
  이때 해결 방안으로 클로저를 이용하면 외부함수의 지역변수를 사용하여 외부로부터 변수의 값이 변경되는 것을 방지하고 불변성을 유지하며 유용하게 쓰이게 됩니다.
  </Details>
  
3. 기존 js문법 vs ES6 문법으로 은 무엇이 변경되었나요?
<Details>
  <Summary>답변</Summary>
  첫번째로 템플릿 리터럴이 추가되었습니다. 

문자와 데이터를 섞어서 사용시 따옴표와 + 를 사용했던 기존방식에서 백틱과 달러표시로 간결하게 사용가능합니다.

두번째로 구조분해 할당입니다.

배열이나 객체의 속성 혹은 값을 해체해서 그 값을 변수에 각각 담아 사용하는것을 말합니다. 

기존에는 각각의 값을 전부 꺼내써야하는 번거로움과 코드를 더 조잡하게 보이게하는 단점이 있었습니다.

비구조화 할당은  할당하려는 변수명과 구조화된 데이터의 속성명이 같으면 기존의 배열값을 변수에 한꺼번에 할당 가능하고 스프레드 연산자 사용시 값 자체를 복사하고 분리하여 원하는 값만 선택할 수 있습니다.

세번째로 화살표 함수의 추가입니다.

화살표함수는 매개변수가 한개일때 소괄호가 생략 가능하여 간결한 함수식일 때 한줄표현도 가능하고

이때 중괄호와 리턴도 생략이 가능합니다.

익명함수로만 사용할 수 있기 때문에 함수표현식을 사용합니다.(호이스팅불가) /여기까지-용준

map 과 같은 콜백함수로 표현 가능하고

일반함수와의 가장 큰 차이점은 this 바인딩 객체결정방식에 있습니다. ⇒ 일반함수 vs 화살표함수 질문으로 이어짐.

옵셔널 체이닝(optional chaining) `?.`을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.

-세경

첫번째는 let, const 변수입니다. 할당된 값을 변경 불가능하게 하는 변수키워드등장하였다.

두번째는 화살표함수입니다.

화살표함수는 매개변수가 한개일때 소괄호가 생략 가능하여 간결한 함수식일 때 한줄표현도 가능하고

이때 중괄호와 리턴도 생략이 가능합니다.

세번째는 템플릿 문자열의 등장입니다. 문자열을 연결하기 위해 더하기연산자를 사용할 필요 없이 백틱을 사용하여 문자열 내에서 변수를 사용할 수 있게 되었다.

네번째는 구조분해할당문법입니다. 배열이나 객체의 속성 혹은 값을 해체해서 그 값을 변수에 각각 담아 사용하는것을 말합니다. 

네번째는 기본 매개변수입니다. 기본 매개 변수를 사용하면 정의되지 않은 매개 변수가 반환되지 않고 매개 변수 할당을 잊어버렸을 때 해당 값이 사용됩니다, 즉 매개변수할당을 잊어버릴 경우를 대비해 할당된 값이 없을 경우 처음에 설정해 놓은 값으로 사용하여 오류를 미리 처리할 수 있게 되었습니다.

다섯번째는 Promises입니다. 비동기 코드를 쓰는 방법으로 등장하게 되었습니다.

여섯번째는 import and export입니다. 모듈을 가져올 때는 Import사용하며 내보낼 때는 export를 사용하는 문법입니다.
</Details>

4. 호이스팅이 무엇인가요? var, let, const의 차이는 무엇인가요?

<Details>
  <Summary>답변</Summary>
  
</Details>

5. undefined vs null과 차이가 무엇인가요?
<Details>
  <Summary>답변</Summary>
  먼저 변수 선언방식에 대해서 간단하게 말씀드리자면, 변수를 선언할 때 메모리에 변수공간을 생성하게 됩니다. 그 공간에 어떤 데이터가 할당되기 전까지 자바스크립트 엔진에 의해 undefined라는 값을 기본으로 갖고 있습니다. 즉 undefined는 변수를 선언하고 값을 할당하지 않은 상태를 말하는데, null은 변수를 선언하고 빈 값을 할당한 상태를 말합니다. 의도적으로 변수 공간이 비어있음을 명시할때 null을 사용해 줍니다. 따라서 typeof를 통해 자료형을 확인해보면 null은 object로 undefined는 undefined가 출력되는 것으로 확인할 수 있습니다.
</Details>

6. 자바스크립트 원시/참조타입에 대해서 말해보세요.
<Details>
  <Summary>답변</Summary>
  자바스크립트에는 원시타입과 참조타입이 있습니다. 원시타입은 하나의 정보, 하나의 데이터를 담고있는 자료형을 말합니다. 값 자체에 대한 변경은 불가능하지만, 변수에 다른 데이터를 할당할 수 있는 특징이 있습니다. 원시타입에는 boolean, number, string, undefined등등 같은 타입이 있습니다. 
  참조타입은 하나의 데이터가 아닌 여러 데이터가 담고있는 자료형을 말합니다. 값을 주소에 저장하고 출력시 메모리 주소와 일치하는 값을 출력합니다. 참조타입에는 배열, 객체, 함수등이 있습니다.
</Details>
7. 일반함수와 화살표함수의 차이점에 대해서 말해보세요.
<Details>
  <Summary>답변</Summary>
  가장 큰 차이점은 this 바인딩이 있습니다. 
</Details>
8. DOM과 vitualDom에 대해서 설명해 주세요.
<Details>
  <Summary>답변</Summary>
  DOM 웹페이지를 구성하는 요소를 구조화해서 나타낸 객체입니다 .
즉 HTML문서를 객체기반표현방식으로 표현한 것을 말합니다. 
DOM이 브라우저에 렌더링되는 과정은 HTML을 파싱하여 DOM 객체를 생성하고, CSS를 파싱하여 스타일 규칙을 만듭니다. 이 두개를 합쳐서 실제로 웹 브라우저에 보여져야할 요소를 표현한 "렌더 트리" 라는 것을 만듭니다. 이 렌더 트리를 기준으로 레이아웃을 배치하고 색을 칠하는 등의 작업을 통해 DOM이 브라우저에 렌더링됩니다. 이 과정이 DOM의 조작에 의해 반복적으로 실행됩니다. 그 만큼 브라우저가 렌더링을 자주하게 됩니다. 이렇게 여러번 렌더링이 되면서 비효율적인 작업을 하게됩니다. 이를 해결하기 위해 virtualDOM을 사용하게 되었습니다. 
vitualDOM은 **DOM을 추상화한 가상의 객체를 메모리에 만들어 놓은 것** 이며 변경사항을 DOM에 직접 수정하는게 아니라 중간 단계로 vitual DOM을 수정하고 virtual DOM을 통해서 DOM을 수정하는 이런 일렬에 과정이 나타며 vituralDOM은 DOM에 대해 비교하여 변경사항에 대해서만 DOM에 반영하는 것을 말합니다. 변경사항이 있는 부분만 변경 됩니다.
이로 인해 더 반응성이 빠른 웹을 구현할 수 있습니다.
  
  
 vitual Dom은 dom차원에서의 더블 버퍼링이랑 다름 없는데 변화가 일어나면 dom tree에 적용시킨 후 dom tree가 렌더링전에 모든 변화를 하나 모아놓고 한번에 렌더링하는 개념이다. 즉 메모리를 생성해 dom의 변화를 객체에 저장해놓은 후 dom에 대해 비교하여 변경사항을 반영해서 한번 렌더링하는 것을 말한다. 더 반응성이 빠른 웹을 구현할 수 있다.
</Details>
9. CSR vs SSR에 차이점과 각 장점과 단점에 대해서 설명해 주세요.
<Details>
  <Summary>답변</Summary>
  SSR 은 mpa가 체택한 렌더링 방식으로 서버사이드 렌더링의 약자입니다. 서버로부터 완전히 만들어진 html파일을 받아와 페이지 전체를 렌더링하는 방식입니다.  즉 웹서버에서 html, css, javascript파일을 미리 한번 실행시킨 후 브라우저에게 건네주는 방식 그렇게 되면 api통신을 웹서버에서 미리 진행해서 데이터를 적용해 최종적으로 결과가 적용된 파일을 받게 되어 브라우저는 더빠르게 화면을 볼 수 있다는 첫 로딩이 빠르다는 장점이 있습니다. 하지만 단점으로는  사용자 경험이 안좋은데요. time to view, time to interact 에 시간 간격의 차이가 있어 초기에 사용자가 버튼 클릭하더라도 반응하지 않을 수 있습니다. 또 그리고 서버로부터 모든 페이지를 받아오기 때문에 필요없는 부분까지 렌더링하게되어 웹서버가 그만큼 일을 더 하게 된다.

CSR은 spa가 체택한 렌더링 방식으로 클라이언트 사이드 렌더링의 약자입니다. 브라우저 측에서 html, css, javascript파일을 처음부터 실행시키는 방식으로 전부 브라우저에서 렌더링하게 된다. 즉, 웹서버에서 javascript파일을 실행 후 api로부터 받아온 데이터를 뿌려준 후 유저에게 데이터를 보여주는 것을 말합니다. 사용자의 요청에 따라 필요한 부분만 응답받아 렌더링 하는 방식으로 csr은 필요한 부분만 받아오기 때문에 서버부하를 줄일 수 있고, 하지만, ssr보다 초기로딩이 느리다는 단점이 있습니다.
</Details>

10. 얕은복사와 깊은 복사에 대해서 설명해주세요
<Details>
  <Summary>답변</Summary>
  
</Details>

## React 관련
1. React를 사용하는 이유?
<Details>
  <Summary>답변</Summary>
  리액트는 single page application에서 사용자 인터페이스를 구성하는데 사용되는 오픈 소스 프론트엔드 자바스크립트 라이브러리입니다.
  singlepage application이란 처음 html페이지를 하나 불러온 다음, 이후 페이지들을 자바스크립트로 로드하는 특징이 있는 것을 말합니다. singlepage application을 사용하는 이유는 기존에는 화면 접환이 일어날때 마다 html을 계속 서버에 요청하기 때문에 사용자의 상태를 유지하기 힘들었습니다. 하지만 singlepage application에서는 사용자의 상태를 유지하기 쉽습니다. 바뀌지 않은 부분까지 새로 불러오기 때문에 불필요한 로딩이 있어 비효율적이었던 방식에서 바뀐부분만 새로 불러오는 효율적인 방식으로 프로그램을 만들 수 있기에 react를 사용하는 이유입니다.
</Details>

2. React의 특/장점과 단점은 무엇인가요?
<Details>
  <Summary>답변</Summary>
  특징으로는 선언형 프로그래밍과 컴포넌트 기반 개발을 볼 수 있습니다. 한 페이지를 보여쥐 위해 html, css, js파일 나눠어서 적어야하 했지만 react에서는 하나의 파일에 명시적으로 작성할 수 있게 JSX문법을 활용한 선언형 프로그램밍을 할 수 있다는 특징이 있습니다.
  또한 기능별로 구현한 여러 종류의 코드를 묶어둔 컴포넌트를 기반으로 개발하는 특징이 있습니다. 컴포넌트 기반으로 코드를 짰을 때 기능별로 컴포넌트를 분리하고 분리하므로써 서로 독립적이며 재사용이 용이하게 만들 수 있습니다. 또한 어떤 기능이 작동하지 않을 때 해당기능을 하는 컴포넌트로 가서 에러를 찾을 수 있어서 유지 보수가 편합니다.
  
 단점으로는 리액트는 보여지는 부분에만 관여하기 때문에 데이터모델링, routing, ajax등등 기능을 제공하지 않습니다. view외의 기능들은 직접구현하거나 라이브러리를 사용하여 구현해야하기 때문에 javascript을 잘알고 사용해야하는 부분이 있습니다.
</Details>

3. state와 props에 대한 설명을 해주세요
<Details>
  <Summary>답변</Summary>
  먼저 props는 상위 컴포넌트가 하위 컴포넌트에게 내려주는 데이터를 말합니다. props는 객체이며, 읽기전용입니다. 하위컴포넌트는 props를 변경할 수 없고 사용만 할 수 있으며, 이점이 변경되지 말아야 할 데이터를 효율적으로 관리할 수 있게 해줍니다.
  
  state는 컴포넌트가 독립적으로 갖은 상태를 말합니다. 컴포넌트 안에서만 제어되고 보관, 관리되는데, state는 class component만 가질 수 있습니다. 또한 state를 직접 변경할 수 없고, react component의 내장메소드인 setState()를 사용해 변경해야만 합니다.
  
</Details>

4. React class형과 함수형에 차이에 대해서 설명해주세요


5. react에서 life cycle이란 무엇인가요?
<Details>
  <Summary>답변</Summary>
  Life Cycle은 "컴포넌트가 생성, 업데이트, 삭제 될 때 일어나는 일련의 과정"들이고, 각 단계의 전, 후로 미리 지정되어 있는 특정 생명주기 메소드들이 실행됩니다.
  클래스 기반 컴포넌트는 그들이 mount(DOM에 렌더링)되었을 때, unmount될 때 등과 같이 그들의 생명주기 중 특정한 시점에 호출되는 특별한 메소드를 선언할 수 있습니다. 이는 예를 들면 컴포넌트가 필요로 하는 것을 셋팅 및 해제하거나, 타이머를 설정하거나 브라우저 이벤트에 바인딩하는 데 유용합니다.

아래의 생명주기 메소드들은 컴포넌트를 불러오기 위해 사용할 수 있습니다.

- componentWillMount: 컴포넌트가 생성된 후 DOM에 렌더링되기 전에 호출됩니다.
- componentDidMount: 처음으로 렌더링이 끝나고 컴포넌트의 DOM 엘리먼트가 사용 가능할 때 호출됩니다.
- componentWillReceiveProps: props가 업데이트 될 때 호출됩니다.
- shouldComponentUpdate: 새로운 props를 받았을 때 호출되며, 성능 최적화를 위해 리랜더링을 막을 수 있습니다.
- componentWillUpdate: 새로운 props를 받았고 shouldComponentUpdate가 true를 리턴할 때 호출됩니다.
- componentDidUpdate: 컴포넌트가 업데이트된 후에 호출됩니다.
- componentWillUnmount: 컴포넌트가 DOM에서 제거되기 전에 호출되어 이벤트리스너 등을 정리할 수 있게 해줍니다.
</Details>

6. useEffect가 무엇이며, 두번째 인자의 형태에 따라 어떻게 실행되나요?
<Details>
  <Summary>답변</Summary>
  
</Details>

7. useState가 무엇이며, 어떻게 작동이 되나요?
<Details>
  <Summary>답변</Summary>
  동적으로 바뀌는 값을 관리 할때 사용하는데, 상태 유지값과 그 값을 갱신하는 함수를 반환하는 react hook입니다.
  최초로 렌더링을 하는 동안, 반환된 state는 첫번째인자는 initialState의 값과 같으며, 상태를 변경 시에는 두번째인자에 있는 함수를 이용하여 상태를변경시킵니다.
</Details>

8. useRef에 대해서 설명해주세요
<Details>
  <Summary>답변</Summary>
DOM을 선택하여 컴포넌트 안에서 조회, 수정할 수 있는 변수 관리하는 react hook입니다. 
JavaScript 를 사용 할 때에는, 우리가 특정 DOM 을 선택해야 하는 상황에 getElementById, querySelector 같은 DOM Selector 함수를 사용해서 DOM 을 선택합니다.
리액트를 사용하는 프로젝트에서도 가끔씩 DOM 을 직접 선택해야 하는 상황이 발생 할 때도 있습니다. 예를 들어서 특정 엘리먼트의 크기를 가져와야 한다던지, 스크롤바 위치를 가져오거나 설정해야된다던지, 또는 포커스를 설정해줘야된다던지 등 정말 다양한 상황
useRef() 를 사용하여 Ref 객체를 만들고, 이 객체를 우리가 선택하고 싶은 DOM 에 ref 값으로 설정해주어야 합니다. 그러면, Ref 객체의 .current 값은 우리가 원하는 DOM 을 가르키게 됩니다.
</Details>
9. Lifting state up에 대해서 설명해주세요
<Details>
  <Summary>답변</Summary>
  react는 단방향 데이터 플로우를 가지고 있으며 이말은 즉, 부모만 자식에게 데이터를 줄 수 있다는 말입니다. 하지만 자식이 부모의 상태를 변경해야 할 경우를 우리는 Lifting state up이라는 것을 이용합니다. 상위 컴포넌트에서 state을 변경시키는 함수를 만들어 자식컴포넌트에 props로 넘깁니다. 그리고 그 자식컴포넌트에서 함수를 받아 함수를 실행하게 되면 부모의 상태가 변경됩니다. 이를 lifting state up이라고 말합니다.
</Details>

## redux 관련
1. redux의 특징에 대해서 말해보세요
<Details>
  <Summary>답변</Summary>
  첫번째 특징은 store는 오직 하나만 존재한다입니다. 애플리케이션의 모든 상태는 하나의 스토어 안에 하나의 객체 트리 구조로 저장됩니다.
  두번째 특징은 store의 state는 읽기전용이며, 오직 action객체를 통해서만 변경할 수 있습니다. action은 type과 데이터를 담고있는 객체로 이루어져있으며 상태를 변화시키는 유일한 방법은 무슨 일이 벌어지는 지를 묘사하는 액션 객체를 전달하는 방법으로 상태를 변화시킵니다.
  세번째 특징은 reducer은 순수함수라는 특징입니다. reduce는 action과 이전 state를 입력으로 받아서 새로운 state를 리턴하는 함수입니다. 순수함수로 상태를 업데이트해야하며 다른 외부요인으로 상태값이 변경되어서는 안되는 특징을 가지고 있습니다.
</Details>

2. redux를 사용하는 이유, 사용했을 때 장, 단점에 대해서
<Details>
  <Summary>답변</Summary>
  사용하는 이유는 애플리케이션의 여러 곳에서 공유되는 데이터를 상태관리하기에 용이하며, 다른페이지를 갔다가 돌아왔을때 그 상태를 유지할 필요가 있는 데이터가 있을때 redux를 사용하면 상태를 유지하며 사용가능하게 합니다. 즉, 어떠한 데이터를 애플리케이션 전역으로 사용할 때 사용하기 좋습니다. 
 리덕스의 장점은 상태를 예측가능하게 만든다이며 유지보수에 용이하다, 디버깅에 유리하다 입니다.
  복잡한 상태관리와 어떤 액션에 의해 상태가 변했는지 명시적으로 표현되어 있어 유지보수가 용이하고, 상태를 예측가능하게 만들어줍니다. 
  또한 순수함수를 사용하여 다른 외부요인에 의해서 변경되지 않아 이또한 상태를 예측가능하게 만들어 줍니다.
  단점으로는 코드량이 많아집니다. 아주 작은 기능이라도 redux로 구현되면 몇개의 파일들을 필수로 만들어야하고, 다른 액션을 취할 때마다 새로운 액션을 만들어줘야 합니다.
</Details>


## 네트워크
1. HTTP vs HTTPS
