

## 버블정렬(Bubble sort)

- 버블 정렬은 인접한 두 원소를 비교하여 자리를 교환해가며 정렬하는 알고리즘입니다.
- 오름차순으로 정렬한다면 첫번째 순서에는 처음부터 마지막 원소까지 비교하여 결과적으로 마지막 위치에 가장 큰 값이 위치하게 되고, 두 번째 순서에는 마지막 원소를 제외하고 같은 과정을 반복하며 정렬하는 방식입니다. 구현이 간단하지만 **O(n2)의 시간복잡도**를 갖는 비효율적인 정렬 방식입니다.

```js

const swap = function (idx1, idx2, arr) {
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]
}


let bubbleSort = function (arr) {
  let N = arr.length;

  for (let i = 0; i < N; i++) {
    // swap 횟수를 기록한다.
    // 어떤 요소도 swap되지 않은 경우, 배열은 정렬된 상태이다.
    let swaps = 0;

    // 매 반복(iteration)마다 i번째로 큰 수가 마지막에서 i번째 위치하게 된다.
    // 이미 정렬된 요소는 고려할 필요가 없으므로, 'j < N - 1 - i'만 비교하면 된다.
    for (let j = 0; j < N - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swaps++;
        swap(j, j + 1, arr);
      }
    }

    if (swaps === 0) {
      break;
    }
  }

  return arr;
};

```

## 삽입정렬(insertion sort)

- 삽입 정렬은 두번째 위치부터 시작하여, 그 앞의 이미 정렬된 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 알고리즘입니다. 평균 시간복잡도는 O(n2)이며, 가장 빠른 경우 O(n)까지 빨라질 수 있습니다.


```js

const swap = function (idx1, idx2, arr) {
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]
}


let bubbleSort = function (arr) {
  let N = arr.length;

  for (let i = 0; i < N; i++) {
    // swap 횟수를 기록한다.
    // 어떤 요소도 swap되지 않은 경우, 배열은 정렬된 상태이다.
    let swaps = 0;

    // 매 반복(iteration)마다 i번째로 큰 수가 마지막에서 i번째 위치하게 된다.
    // 이미 정렬된 요소는 고려할 필요가 없으므로, 'j < N - 1 - i'만 비교하면 된다.
    for (let j = 0; j < N - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swaps++;
        swap(j, j + 1, arr);
      }
    }

    if (swaps === 0) {
      break;
    }
  }

  return arr;
};
```
