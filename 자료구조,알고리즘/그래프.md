## ê·¸ë˜í”„(Graph)
ê·¸ë˜í”„ëŠ” ì—¬ëŸ¬ê°œì˜ ì ë“¤ì´ ì„œë¡œ ë³µì¡í•˜ê²Œ ì—°ê²°ë˜ì–´ ìˆëŠ” ê´€ê³„ë¥¼ í‘œí˜„í•œ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì§ì ‘ì ì¸ ê´€ê³„ê°€ ìˆëŠ” ê²½ìš° ë‘ ì  ì‚¬ì´ë¥¼ ì´ì–´ì£¼ëŠ” ì„ ì´ ìˆìŠµë‹ˆë‹¤. ê°„ì ‘ì ì¸ ê´€ê³„ë¼ë©´ ëª‡ ê°œì˜ ì ê³¼ ì„ ì— ê±¸ì³ ì´ì–´ì§‘ë‹ˆë‹¤. í•˜ë‚˜ì˜ ì ì„ ê·¸ë˜í”„ì—ì„œëŠ” ì •ì (vertex)ì´ë¼ê³  í‘œí˜„í•˜ê³ , í•˜ë‚˜ì˜ ì„ ì€ ê°„ì„ (edge)ì´ë¼ê³  í•©ë‹ˆë‹¤. <br /.

ëŒ€í‘œì ì¸ ì˜ˆ ) ì„œìš¸-ëŒ€ì „, ëŒ€ì „-ë¶€ì‚°, ë¶€ì‚°-ì„œìš¸ì´ë ‡ê²Œ ê¸¸ì°¾ê¸°, ë„¤ë¹„ê²Œì´ì…˜, SNSì—ì„œ ì‚¬ëŒë“¤ê³¼ì˜ ê´€ê³„, í¬í„¸ ì‚¬ì´íŠ¸ì˜ ê²€ìƒ‰ ì—”ì§„ë“±ì—ì„œ ì‚¬ìš©í•˜ëŠ” ìë£Œêµ¬ì¡°ê°€ ë°”ë¡œ ê·¸ë˜í”„

- ë¹„ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ : ê°„ì„ ì— ì¶”ê°€ì ì¸ ì •ë³´ë¥¼ íŒŒì•…í•  ìˆ˜ ì—†ëŠ” ê·¸ë˜í”„
- ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ : ê°„ì„ ì— ì¶”ê°€ì ì¸ ì •ë³´ë¥¼ íŒŒì•…ê°€ëŠ¥í•œ ê·¸ë˜í”„


### ğŸ’ ê·¸ë˜í”„ êµ¬í˜„

```js
// directed graph (ë°©í–¥ ê·¸ë˜í”„)
// unweighted (ë¹„ê°€ì¤‘ì¹˜)
// adjacency matrix (ì¸ì ‘ í–‰ë ¬)
// ì´í•´ë¥¼ ë•ê¸° ìœ„í•´ ê¸°ì¡´ ë°°ì—´ì˜ ì¸ë±ìŠ¤ë¥¼ ì •ì ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤ (0, 1, 2, ... --> ì •ì )

class GraphWithAdjacencyMatrix {
	constructor() {
		this.matrix = [];
	}

	addVertex() {
        //ë²„í…ìŠ¤ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
		const currentLength = this.matrix.length;
		for (let i = 0; i < currentLength; i++) {
			this.matrix[i].push(0);
		}
		this.matrix.push(new Array(currentLength + 1).fill(0));
	}

	contains(vertex) {
        //TODO: ë²„í…ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        if(this.matrix[vertex]) {
          return true
        }
        return false
	}

	addEdge(from, to) {
		
	const currentLength = this.matrix.length;
	if (from === undefined || to === undefined) {
		console.log("2ê°œì˜ ì¸ìê°€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.");
		return;
	}
		
        //TODO: ê°„ì„ ì„ ì¶”ê°€í•  ìˆ˜ ì—†ëŠ” ìƒí™©ì—ì„œëŠ” ì¶”ê°€í•˜ì§€ ë§ì•„ì•¼ í•©ë‹ˆë‹¤.
	
	if (from + 1 > currentLength || to + 1 > currentLength || from < 0 || to < 0) {
		console.log("ë²”ìœ„ê°€ ë§¤íŠ¸ë¦­ìŠ¤ ë°–ì— ìˆìŠµë‹ˆë‹¤.");
		return;
	}
	
        //TODO: ê°„ì„ ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.
        this.matrix[from][to] = 1

	}

	hasEdge(from, to) {
		//TODO: ë‘ ë²„í…ìŠ¤ ì‚¬ì´ì— ê°„ì„ ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        if(this.matrix[from][to] === 1) {
        return true
        } else {
        return false
        }
	}

	removeEdge(from, to) {
		const currentLength = this.matrix.length;
		if (from === undefined || to === undefined) {
			console.log("2ê°œì˜ ì¸ìê°€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.");
			return;
		}
        //TODO: ê°„ì„ ì„ ì§€ìš¸ ìˆ˜ ì—†ëŠ” ìƒí™©ì—ì„œëŠ” ì§€ìš°ì§€ ë§ì•„ì•¼ í•©ë‹ˆë‹¤.
		if (from + 1 > currentLength || to + 1 > currentLength || from < 0 || to < 0 || this.matrix[from][to] === 0) {
      return;
		}
        //TODO: ê°„ì„ ì„ ì§€ì›Œì•¼ í•©ë‹ˆë‹¤.
        this.matrix[from][to] = 0
	}
}

```

```js

let matrix = [
[1, 1, 0, 0]
[0, 0, 1, 0]
[1, 0, 0, 1]
[1, 1, 0, 1]
]

function getDirections(matrix, from, to) {
  // TODO: ì—¬ê¸°ì— ì½”ë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.

  let n = matrix.length;
  
  // ë°©ë¬¸í•œ ê³³ ì²´í¬
  let isVisited = Array.from({length:n}, () => false)

  function DFS (v){
    if(v===to) {
      return;
    } else {
      for(let i = 0; i < matrix.length; i++) {
      
           // ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìœ¼ë©° ê°„ì„ ì´ ìˆëŠ” ê²½ìš°
          if(matrix[v][i]===1 && !isVisited[i]){
          isVisited[i]=true;
          DFS(i)
        }
    }
  }
  }
  isVisited[from]=true;
  DFS(from)

  return isVisited[to];
}
```

## DFS(Depth First Search) ê¹Šì´ìš°ì„ íƒìƒ‰
DFSëŠ” í•˜ë‚˜ì˜ ê²½ë¡œë¥¼ ëê¹Œì§€ íƒìƒ‰í•œ í›„, ë‹¤ìŒ ê²½ë¡œë¡œ ë„˜ì–´ê°€ íƒìƒ‰

ëª¨ë“  ê²½ë¡œë¥¼ íƒìƒ‰í•  ë•Œ,

ê¹Šì´ë¥¼ ìš°ì„ ì ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” ë°©ë²•

BFSë³´ë‹¤ íƒìƒ‰ ì‹œê°„ì€ ì¡°ê¸ˆ ì˜¤ë˜ ê±¸ë¦´ì§€ë¼ë„ ëª¨ë“  ë…¸ë“œë¥¼ ì™„ì „íˆ íƒìƒ‰

ğŸ’ treeDFS
```js
let dfs = function (node) {
  // TODO: ì—¬ê¸°ì— ì½”ë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.
  let result = [node.value]

  if(node.children) {
    for(let i = 0; i < node.children.length; i++) {
      let output = dfs(node.children[i])
        result = [...result, ...output]
    }
   
  }
  return result
};

// ì´ ì•„ë˜ ì½”ë“œëŠ” ë³€ê²½í•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤. ììœ ë¡­ê²Œ ì°¸ê³ í•˜ì„¸ìš”.
let Node = function (value) {
  this.value = value;
  this.children = [];
};

// ìœ„ Node ê°ì²´ë¡œ êµ¬ì„±ë˜ëŠ” íŠ¸ë¦¬ëŠ” ë§¤ìš° ë‹¨ìˆœí•œ í˜•íƒœì˜ íŠ¸ë¦¬ì…ë‹ˆë‹¤.
// membership check(ì¤‘ë³µ í™•ì¸)ë¥¼ ë”°ë¡œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
Node.prototype.addChild = function (child) {
  this.children.push(child);
  return child;
};
```

ğŸ’ ëª¨ë“  ë¶€ë¶„ì§‘í•© êµ¬í•œê¸°
```js
[1, 2, 3, 4, 5]

function solution(n) {
	let answer = [];
	let ch = Array.from({length:n+1}, ()=> 0}

	function DFS(L) {
		if(L===n+1){
			let tmp = "";
			for(let i=1; i<=n; i++){
				if(ch[i]===1)tmp+=(i+" ");
			}
			if(tmp.length>0){
				answer.push(tmp.trim());
			} else {
				ch[L]=1; 
				DFS(L+1);
				ch[L]=0;
				DFS(L+1);
			}
		}
	DFS(1);
	return answer;
}
```

ğŸ’ ì—¬í–‰ëª¨ë“ ê²½ë¡œ êµ¬í•˜ê¸°
```js
[["ICN", "SFO"], ["ICN", "ATL"], ["SFO", "ATL"], ["ATL", "ICN"], ["ATL","SFO"]]

function solution (tickets) {
		
	tickets.sort()
        //[["ATL", "ICN"], ["ATL","SFO"], ["ICN", "ATL"], ["ICN", "SFO"], ["SFO", "ATL"]] 
	let n = tickets.length;
	let isVisited = Array.from({length:n}, ()=>false)

	const DFS = (L, current, path) => {
		
		if(L===n){
			answer = path
			return answer
		} else {
			for(let i = 0; i < n; i++){
				if(tickets[i][0] === current && !isVisited[i]){ 
				//[false, false, true, false, false]
					isVisited[i]=true;
					DFS(L+1, tickets[i][1], [...path, tickets[i][1]]  
				//DFS(1, "ATL", ["ICN", "ATL"])
					isVisited[i]=false;
			}
		}
	}
	DFS(0, "ICN", ["ICN"])
	
	return answer;
}
```

## BFS(Breath First Search) ë„“ì´ìš°ì„ íƒìƒ‰

ì£¼ë¡œ ë‘ ì •ì  ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ì„ ë•Œ,
ê°€ê¹Œìš´ ì •ì ë¶€í„° íƒìƒ‰í•´ì„œ

ğŸ’ treeBFS
```js
ê°™ì€ ë ˆë²¨ì— ìˆëŠ” ë…¸ë“œë¥¼ ë¨¼ì € ì°¾ì•„ê°„ë‹¤.

let bfs = function (node) {
	
	let queue = [node.value]
	let values = []
	
	while(queue.length > 0) {

		let head = queue[0]
		queue = queue.slice(0)
		values.push(head.value)
		head.children.forEach(node => queue.push(node))

	}  
	
};

let Node = function (value) {
  this.value = value;
  this.children = [];
};

Node.prototype.addChild = function (child) {
  this.children.push(child);
  return child;
};

```

ğŸ’ ë‹¨ì–´ë³€í™˜
```js

begin ; "hit"
target ; "cog"
words ; ["hot", "dot", "dog", "lot", "log", "cog"]

function solution(begin, target, words){
	
	let queue = [];
	let count = 0;
	let n = words.length
	let isVisited = Array.from({length:n}, ()=>false)
	
	queue.push([begin, answer]) 
	while(queue.length > 0){
		
		let [now, count] = queue.shift()
		
		if(now === target) {
			answer = count;
			return answer;
		} else {
			for(let i = 0; i < words.length; i++){
				let differWord = 0;
				for(let j = 0; j < words[i].length; j++){
						if(words[i][j] !== now[j]){
								differWord+=1;
						}
				}
				if(differWord === 1 && !isVisited[i]){
					isVisited[i] = true
					queue.push([words[i], ++count])
				}
		}

	}
	return answer
}
```

### ì¦‰ DFSëŠ” ëª¨ë“  ê²½ë¡œë¥¼ ì°¾ì„ ë•Œ ì“°ë©°, BFSëŠ” ìµœë‹¨ê²½ë¡œë¥¼ ì°¾ì„ë•Œ ì£¼ë¡œ ì“°ì¸ë‹¤.
