## 그래프(Graph)
그래프는 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조입니다. 직접적인 관계가 있는 경우 두 점 사이를 이어주는 선이 있습니다. 간접적인 관계라면 몇 개의 점과 선에 걸쳐 이어집니다. 하나의 점을 그래프에서는 정점(vertex)이라고 표현하고, 하나의 선은 간선(edge)이라고 합니다. <br /.

대표적인 예 ) 서울-대전, 대전-부산, 부산-서울이렇게 길찾기, 네비게이션, SNS에서 사람들과의 관계, 포털 사이트의 검색 엔진등에서 사용하는 자료구조가 바로 그래프

- 비가중치 그래프 : 간선에 추가적인 정보를 파악할 수 없는 그래프
- 가중치 그래프 : 간선에 추가적인 정보를 파악가능한 그래프


### 💎 그래프 구현

```js
// directed graph (방향 그래프)
// unweighted (비가중치)
// adjacency matrix (인접 행렬)
// 이해를 돕기 위해 기존 배열의 인덱스를 정점으로 사용합니다 (0, 1, 2, ... --> 정점)

class GraphWithAdjacencyMatrix {
	constructor() {
		this.matrix = [];
	}

	addVertex() {
        //버텍스를 추가합니다.
		const currentLength = this.matrix.length;
		for (let i = 0; i < currentLength; i++) {
			this.matrix[i].push(0);
		}
		this.matrix.push(new Array(currentLength + 1).fill(0));
	}

	contains(vertex) {
        //TODO: 버텍스가 있는지 확인합니다.
        if(this.matrix[vertex]) {
          return true
        }
        return false
	}

	addEdge(from, to) {
		
	const currentLength = this.matrix.length;
	if (from === undefined || to === undefined) {
		console.log("2개의 인자가 있어야 합니다.");
		return;
	}
		
        //TODO: 간선을 추가할 수 없는 상황에서는 추가하지 말아야 합니다.
	
	if (from + 1 > currentLength || to + 1 > currentLength || from < 0 || to < 0) {
		console.log("범위가 매트릭스 밖에 있습니다.");
		return;
	}
	
        //TODO: 간선을 추가해야 합니다.
        this.matrix[from][to] = 1

	}

	hasEdge(from, to) {
		//TODO: 두 버텍스 사이에 간선이 있는지 확인합니다.
        if(this.matrix[from][to] === 1) {
        return true
        } else {
        return false
        }
	}

	removeEdge(from, to) {
		const currentLength = this.matrix.length;
		if (from === undefined || to === undefined) {
			console.log("2개의 인자가 있어야 합니다.");
			return;
		}
        //TODO: 간선을 지울 수 없는 상황에서는 지우지 말아야 합니다.
		if (from + 1 > currentLength || to + 1 > currentLength || from < 0 || to < 0 || this.matrix[from][to] === 0) {
      return;
		}
        //TODO: 간선을 지워야 합니다.
        this.matrix[from][to] = 0
	}
}

```

```js

function getDirections(matrix, from, to) {
  // TODO: 여기에 코드를 작성합니다.

  let n = matrix.length;
  
  // 방문한 곳 체크
  let isVisited = Array.from({length:n}, () => false)

  function DFS (v){
    if(v===to) {
      return;
    } else {
      for(let i = 0; i < matrix.length; i++) {
      
           // 방문하지 않았으며 간선이 있는 경우
          if(matrix[v][i]===1 && !isVisited[i]){
          isVisited[i]=true;
          DFS(i)
        }
    }
  }
  }
  isVisited[from]=true;
  DFS(from)

  return isVisited[to];
}
```
