## ìˆœì—´ ì•Œê³ ë¦¬ì¦˜

### DFS templete

```js

// DFS ê¹Šì´ìš°ì„ íƒìƒ‰ì´ë‹¤ 
 const DFS = (L) => {
 
      // ì–´ë–¤ ì¡°ê±´ì— ë„ë‹¬í–ˆì„ ê²½ìš°
     if (L === choiceNum) {
      recipe.push(tmp.slice());
    } else {
    
      // ë°˜ë³µë¬¸ì„ ëŒë©° 
      for (let i = 0; i < Len; i++) {
        
        // ë°©ë¬¸ì„ ì•ˆí•œê²½ìš°
        if (check[i] === 0) {
          // ë°©ë¬¸ ì²´í¬
          check[i] = 1;
          tmp[L] = newRecipe[i];
          DFS(L + 1);
          check[i] = 0;
        }
      }
    }
  };


```

### 0ìœ¼ë¡œ ì±„ì›Œì§„ ë°°ì—´ë§Œë“¤ê¸°

```js

  // 0ìœ¼ë¡œ ì±„ì›Œì§„ ë°°ì—´ë§Œë“¤ê¸°
  let check = Array.from({ length: Len }, () => 0);
  let tmp = Array.from({ length: choiceNum }, () => 0);
  

```

*ê°œì—… ì´ë˜ë¡œ í•­ìƒ ìŠ¹ìŠ¹ì¥êµ¬í•˜ëŠ” 'ìŠ¹ìŠ¹ì¥êµ¬ ì¹˜í‚¨ì§‘'ì˜ ë¹„ê²°ì€ ì†ŒìŠ¤ì— ìˆë‹¤. ìˆ˜ë§ì€ íƒ€ì‚¬ ë¸Œëœë“œ ì¹˜í‚¨ì§‘ë“¤ì´ ìŠ¹ìŠ¹ì¥êµ¬ ì¹˜í‚¨ì§‘ì˜ ì†ŒìŠ¤ ë¹„ê²°ì„ ì•Œì•„ë‚´ë ¤ê³  í–ˆìœ¼ë‚˜ ë¹ˆë²ˆíˆ í¬ê¸°í–ˆë‹¤.
ê·¸ ì´ìœ ëŠ” 5ëŒ€ì§¸ ë‚´ë ¤ì˜¤ëŠ” 'ë¹„ë°€ì˜ ìŠ¹ìŠ¹ì¥êµ¬ ì¹˜í‚¨ ì†ŒìŠ¤ ë¹„ìœ¨ ë ˆì‹œí”¼'ëŠ” 70ì–µ ì¸êµ¬ ì¤‘ ì‚¬ì¥ë‹˜ë§Œ ì•Œê³  ìˆê¸° ë•Œë¬¸ì´ë‹¤. ìµœê·¼, ëˆ„ë¦¬ê¾¼ ì‚¬ì´ì—ì„œ ì´ ë ˆì‹œí”¼ì˜ ì¼ë¶€ë¶„ì„ ë°œì·Œí–ˆë‹¤ëŠ” ì†Œë¬¸ì„ ë“£ê²Œ ë˜ì—ˆë‹¤.
ê·¸ ì†Œë¬¸ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.*

ğŸ‘‰ ì…ì¶œë ¥ ì˜ˆì‹œ
```
const output1 = newChickenRecipe([1, 10, 1100, 1111], 2);
console.log(output1);
/*
  [
    [1, 10], [1, 1100], [1, 1111],
    [10, 1], [10, 1100], [10, 1111],
    [1100, 1], [1100, 10], [1100, 1111],
    [1111, 1], [1111, 10], [1111, 1100]
  ];
*/

```

```js
// ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤ forë¬¸ì„ choiceNumë§Œí¼ ë§Œë“¤ì–´ ë°˜ë³µí•˜ëŠ” ê²ƒì´ë‹¤ ì´ëŸ¬í•œ ë°©ë²•ì„ DFSë°©ì‹ìœ¼ë¡œ ì°¾ê¸°ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì´ë‹¤.
function newChickenRecipe(stuffArr, choiceNum) {
  // TODO: ì—¬ê¸°ì— ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”.
  let recipe = [];
  
  let newRecipe = stuffArr.filter(el => {
      let str = String(el)
      let count = 0;
      for(let a of str) {
          if(a === "0") {
              count+=1
          }
      }
      if(count < 3) {
        return el
      }
  })
  
  if(newRecipe.length < choiceNum) {
      return [];
  }

  newRecipe.sort((a,b) => a-b)
  let Len = newRecipe.length;
  let check = Array.from({ length: Len }, () => 0);
  let tmp = Array.from({ length: choiceNum }, () => 0);
  
  const DFS = (L) => {
  
    
     if (L === choiceNum) {
      recipe.push(tmp.slice());
    } else {
      for (let i = 0; i < Len; i++) {
        if (check[i] === 0) {
          check[i] = 1;
          tmp[L] = newRecipe[i];
          DFS(L + 1);
          check[i] = 0;
        }
      }
    }
  };

  DFS(0);
 
  return recipe;
}


```


